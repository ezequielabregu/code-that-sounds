# Sequencers

## Random Melody Generator

This chapter provides a step-by-step explanation of the [music-scale-B.pd](/assets/code/sequencers/music-scale-B.pd) Pure Data patch. The patch demonstrates how to generate a melody using a musical scale, store it in an array, and play it back using MIDI.

![Random Melody Generator](/assets/images/random_melody.png)

---

### Patch Overview

The patch is organized into several functional blocks:

- **Scale and Melody Generation**
- **Melody Storage**
- **Playback Control**
- **MIDI Output**

Below is a simplified diagram of the main data flow:

```{mermaid}
flowchart TD
    A[Scale Input] --> B[Melody Generation]
    B --> C[Store in Array]
    C --> D[Playback Control]
    D --> E[MIDI Output]
```

---

### Scale and Melody Generation

#### Scale Definition

The patch starts with a message box containing the scale intervals:
  
`0 2 4 5 7 9 11`

For example, this represents a major scale in semitones accordding to the following mapping:

:::{style="width: 50%;"}
| Note      | Interval |
|-----------|----------|
| C         | `0`        |
| C# / Db   | `1`        |
| D         | `2`        |
| D# / Eb   | `3`        |
| E         | `4`        |
| F         | `5`        |
| F# / Gb   | `6`        |
| G         | `7`        |
| G# / Ab   | `8`        |
| A         | `9`        |
| A# / Bb   | `10`       |
| B         | `11`       |
:::

&nbsp;

The scale is appended to a list and processed to determine its length.

#### Random Note Selection

A random number between 0 and 47 is generated (`random 48`), then shifted up by 60 to get a MIDI note in a typical range.

The note is then mapped to the scale using modulo operations and list indexing.

#### Melody Construction

The patch uses a loop (`until`, `i`, `+ 1`) to generate a sequence of notes.

Each note is calculated based on the scale and stored in a list.

---

### Melody Storage

The generated melody is stored in a Pure Data array called `melody`.

The array is visualized in the patch for reference.

```{mermaid}
graph LR
    MelodyList -->|tabwrite| MelodyArray
```

---

### Playback Control

A `metro` object (metronome) triggers playback at a tempo set by a horizontal slider.

Each bang from the metronome advances an index, which reads the next note from the `melody` array.

---

### MIDI Output

The note value is sent to a `makenote` object, which creates a MIDI note with velocity and duration.

The note is then sent to the `noteout` object, which outputs the MIDI note to your system's MIDI device.

---

### Step-by-Step Data Flow

1. **Initialize Scale**: The scale intervals are defined and appended to a list.
2. **Generate Melody**: A loop generates random notes mapped to the scale, storing them in the `melody` array.
3. **Playback**: A metronome triggers reading from the array, sending notes to MIDI output.
4. **Visualization**: The melody array is displayed as a graph in the patch.

---

### Key Objects and Their Roles

:::{style="width: 50%;"}
| Object         | Purpose                                      |
|----------------|----------------------------------------------|
| `random 48`    | Generates random note indices                |
| `+ 60`         | Shifts notes to a higher MIDI octave         |
| `mod 12`       | Maps notes to scale degrees                  |
| `list-idx`     | Retrieves scale degree from the list         |
| `tabwrite`     | Writes notes to the `melody` array           |
| `metro`        | Controls playback timing                     |
| `tabread`      | Reads notes from the `melody` array          |
| `makenote`     | Creates MIDI notes with velocity/duration    |
| `noteout`      | Sends MIDI notes to output                   |
:::

---

### Diagram: Melody Generation and Playback

```{mermaid}
flowchart TD
    S[Scale Message] --> L[list Append]
    L --> R[random + Offset]
    R --> M[Modulo/Indexing]
    M --> A[Melody Array]
    A --> P[Playback - metro, tabread]
    P --> MN[makenote]
    MN --> NO[noteout]
```

---

### Summary

This patch demonstrates how to algorithmically generate a melody using a musical scale, store it, and play it back via MIDI in Pure Data. The modular structure allows for easy experimentation with different scales, lengths, and playback parameters.

---

## Euclidean Sequencer
This chapter provides a step-by-step explanation of the [euclidean_sequencer.pd](code/euclidean_sequencer/euclidean_sequencer.pd) Pure Data patch. The patch demonstrates how to create a Euclidean sequencer that generates rhythmic patterns based on the Euclidean algorithm.

### Patch Overview
The patch is organized into several functional blocks:
- **Euclidean Algorithm**
- **Rhythm Generation**
- **Playback Control**
- **MIDI Output**
Below is a simplified diagram of the main data flow