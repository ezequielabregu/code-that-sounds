[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Creative Coding with Pure Data",
    "section": "",
    "text": "Preface\nThis book was born out of the classroom—but it does not stay there. It is the result of many years of teaching creative coding and interactive media at public universities, engaging with students from a wide range of disciplines, backgrounds, and interests. Over time, a common thread emerged: the desire to bridge artistic expression and technical skill, to write code not just as a means to an end, but as a space of exploration, experimentation, and play.\nIn these pages, you’ll find the distilled insights, exercises, and creative strategies that have shaped countless workshops and academic programs. The goal has always been twofold: to equip readers with the tools to build interactive digital systems, and to nurture a mindset where sound, movement, code, and structure can be explored as artistic materials. Whether it’s a generative soundscape, a data-driven artwork, or a custom tool built from scratch, the projects in this book are designed to foster technical growth while encouraging individual expression.\nThis is not a manual in the traditional sense, nor is it a fixed curriculum. Instead, this book invites you to engage with Pure Data on your own terms, navigating its chapters in whatever order best suits your curiosity. The modular structure is intentional: it supports creative detours, sudden insights, and unexpected connections between ideas. You are encouraged to experiment, remix, and stretch the boundaries of the examples presented. Treat the book as both a guide and a sandbox—one where art, sound, code, and interactivity come alive through your engagement.\nWhether you’re an artist exploring new tools, a programmer seeking creative outlets, or a student diving into the world of interactive media, I hope this book helps you discover how code can become a language for imagination.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#who-am-i",
    "href": "index.html#who-am-i",
    "title": "Creative Coding with Pure Data",
    "section": "Who am I?",
    "text": "Who am I?\nMy name is Ezequiel Abregú, and I am a sound artist, composer, multi-instrumentalist, and researcher originally from Buenos Aires, Argentina. My artistic practice encompasses sound recordings, audio installations, performances, sound sculptures, sound design, and compositions for chamber music, choreography, and theater. I am particularly interested in the interplay between music, performance, sound art, live electronics, auditory and visual perception, interactive media, and the application of technology in art.\n\n\n\nDr. Ezequiel Abregú\n\n\nI hold a Ph.D. focusing on the relationship between visual and auditory perception in sound art, and a degree in Composition with Electroacoustic Media from the National University of Quilmes (UNQ). My academic career includes teaching positions at several institutions: I am a professor at the University of Quilmes (Computing Applied to Music area), the National University of Arts (Multimedia Arts area), and the University of Tres de Febrero (Electronic Arts area).\nMy passion for programming and digital audio applications has led me to explore various programming languages and tools over the past two decades, including C, C++, Python, and Pure Data. I am an advocate of the open-source philosophy, regularly working with Linux and sharing my projects in publicly accessible repositories. My technical expertise extends to hardware development using microcontrollers and single-board computers, enabling me to adopt a hands-on approach in both my artistic and research endeavors.\nMore information about my work can be found on my personal website ezequielabregu.net.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#what-is-this-book-about",
    "href": "index.html#what-is-this-book-about",
    "title": "Creative Coding with Pure Data",
    "section": "What is this book about?",
    "text": "What is this book about?\nThis book is the result of years of teaching undergraduate and postgraduate courses at several public universities, where I had the opportunity to explore the intersection of creativity and technology with students from diverse backgrounds. The central aim of these courses—and now this book—has been to blend a creative mindset with programming skills to develop original tools, algorithms, and artworks. Through this synthesis, we also seek to deepen our understanding of sound, interactivity, and control protocols in both technical and expressive ways.\nRather than offering a fixed, linear progression, the structure of this book is deliberately open and modular. Readers are encouraged to navigate the content according to their interests, needs, or curiosity. This flexibility supports an experimental approach to learning, where exploration and play are not only welcome but essential.\nBy approaching programming as a creative practice, this book invites you to think, make, and reflect through code. Whether you’re building an interactive sound installation, prototyping a digital instrument, or simply experimenting with new ideas, the goal is to empower you with the tools and concepts to express yourself in the digital domain—and to enjoy the process along the way.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#who-is-this-book-for",
    "href": "index.html#who-is-this-book-for",
    "title": "Creative Coding with Pure Data",
    "section": "Who is this book for?",
    "text": "Who is this book for?\nThis book is intended for anyone interested in learning about creative coding using Pure Data. It is suitable for beginners who are new to programming and want to explore the world of interactive media, as well as for experienced programmers looking to expand their skills in sound synthesis and data visualization.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#what-are-you-going-to-learn",
    "href": "index.html#what-are-you-going-to-learn",
    "title": "Creative Coding with Pure Data",
    "section": "What are you going to learn?",
    "text": "What are you going to learn?\nIn this book, you will learn how to use Pure Data to create interactive audio-visual projects. You will explore various techniques for sound synthesis, data visualization, and interactive installations. The book will also cover best practices for organizing and managing your Pd projects, as well as tips for debugging and optimizing your code.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#what-are-you-dont-going-to-learn",
    "href": "index.html#what-are-you-dont-going-to-learn",
    "title": "Creative Coding with Pure Data",
    "section": "What are you don’t going to learn?",
    "text": "What are you don’t going to learn?\nThis book is not intended to be a comprehensive guide to all aspects of Pure Data. Instead, it focuses on specific topics and projects that are relevant to creative coding. While the book will cover a wide range of techniques and concepts, it will not delve into every detail or aspect of Pure Data. This book is not a substitute for the official Pure Data documentation or other resources. It is meant to complement these resources and provide a practical, hands-on approach to learning Pure Data.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#pre-requisites",
    "href": "index.html#pre-requisites",
    "title": "Creative Coding with Pure Data",
    "section": "Pre-requisites",
    "text": "Pre-requisites\nTo get the most out of this book, you should have a basic understanding of programming and some familiarity with the Pure Data language.\nIf you are new to Pure Data or programming, there are several free online resources that can help you get started:\n\nPure Data FLOSS Manual – A beginner-friendly and comprehensive guide to Pure Data.\nOfficial Pure Data Documentation – The official manuals and reference materials for Pure Data.\nMiller Puckette’s “Theory and Techniques of Electronic Music” – A comprehensive book by the creator of Pure Data, covering both theory and practical techniques.\nProgramming Electronic Music in Pd - Designed for self-study, principally for composers. It begins with explanations of basic programming and acoustic principles then gradually builds up to the most advanced electronic music processing techniques.\nPatchstorage - A community-driven platform for sharing and discovering Pure Data patches. It features a wide range of projects, from simple examples to complex installations, and serves as a valuable resource for learning and inspiration.\n\nThese resources can be consulted before or alongside this book to strengthen your foundational knowledge.\n\n\n\n\n\n\nRecommended Pure Data distributions\n\n\n\nThis book is based on the Vanilla1 distribution of Pure Data, which is the most widely used version. However, there are several other distributions that you may find useful for specific projects or needs:\n\n\n\nPurr Data – A fork of Pd-l2ork that focuses on usability and accessibility, with a more polished interface and additional features. Purr Data serves the same purpose, but offers a new and much improved graphical user interface and includes many 3rd party plug-ins. Like Pd, it runs on Linux, macOS and Windows, and is open-source throughout.\nPlugdata – plugdata is a plugin wrapper designed for Miller Puckette’s Pure Data (Pd), featuring an enhanced graphical user interface (GUI) created using JUCE, headed by Timothy Schoen. this project is still a work in progress, and may still have some bugs. By default, plugdata comes with the cyclone and ELSE collections of externals and abstractions.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Creative Coding with Pure Data",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nI would like to express my gratitude to the following individuals and organizations for their support and contributions to this book:\n\nPure Data for providing a powerful and flexible platform for creative coding.\nThe Pd community for their invaluable resources, tutorials, and support.\nThe open-source community for their dedication to sharing knowledge and tools for creative coding.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Creative Coding with Pure Data",
    "section": "License",
    "text": "License\nThis book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. You are free to share and adapt the material, provided you give appropriate credit, do not use it for commercial purposes, and distribute your contributions under the same license.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "chapters/introduction.html",
    "href": "chapters/introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 What is Pure Data?\nTraditionally, the process of creating software applications has relied heavily on text-based programming languages. Developers would write code manually in text files and execute them later to observe the outcome. While this method is efficient for those trained in programming, it often presents a steep learning curve for artists, musicians, and other creatives without a technical background. The abstract nature of text-based coding can act as a barrier to entry, especially for those more accustomed to working in visual or tactile media.\nPure Data offers a radically different approach by introducing a graphical programming environment tailored to creative exploration. Instead of writing lines of code, users work with visual representations of functions—called objects—that are placed and connected on a canvas. This paradigm allows users to construct interactive programs, known as “patches,” by literally drawing connections between elements. Each object can receive messages that modify its behavior in real time, creating a highly responsive and accessible system for building audio, visual, or multimedia tools.\nThe design of Pure Data echoes the modular synthesis systems of the 20th century, where sound was shaped by routing audio through a network of physical devices linked with patch cables. This historical reference not only grounds Pure Data in a legacy of experimental electronic music but also makes it intuitive for users familiar with analog workflows. By visually “patching” connections, users can simulate and extend these traditional processes in a digital context.\nTo fully engage with the creative potential of Pure Data, one can develop or modify algorithms for digital audio using imaginative coding strategies. For instance, building a real-time audio granulator that reinterprets live microphone input can offer both technical challenge and artistic reward. Through this lens, programming becomes a form of creative expression, blending logical structures with aesthetic decisions. By experimenting with signal flow, modulation techniques, or interactive sensors, users cultivate a mindset that is both inventive and analytical—unlocking new possibilities in digital sound design and performance.\nPure Data (or Pd) is a real-time graphical programming environment for audio, video, and graphical processing. Pure Data is commonly used for live music performance, VeeJaying, sound effects, composition, audio analysis, interfacing with sensors, using cameras, controlling robots or even interacting with websites. Because all of these various media are handled as digital data within the program, many fascinating opportunities for cross-synthesis between them exist. Sound can be used to manipulate video, which could then be streamed over the internet to another computer which might analyze that video and use it to control a motor-driven installation.\nProgramming with Pure Data is a unique interaction that is much closer to the experience of manipulating things in the physical world. The most basic unit of functionality is a box, and the program is formed by connecting these boxes together into diagrams that both represent the flow of data while actually performing the operations mapped out in the diagram. The program itself is always running, there is no separation between writing the program and running the program, and each action takes effect the moment it is completed.\nThe community of users and programmers around Pure Data have created additional functions (called “externals” or “external libraries”) which are used for a wide variety of other purposes, such as video processing, the playback and streaming of MP3s or Quicktime video, the manipulation and display of 3-dimensional objects and the modeling of virtual physical objects. There is a wide range of external libraries available which give Pure Data additional features. Just about any kind of programming is feasible using Pure Data as long as there are externals libraries which provide the most basic units of functionality required.\nThe core of Pure Data written and maintained by Miller S. Puckette and includes the work of many developers, making the whole package very much a community effort.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/introduction.html#why-pure-data",
    "href": "chapters/introduction.html#why-pure-data",
    "title": "1  Introduction",
    "section": "1.2 Why Pure Data?",
    "text": "1.2 Why Pure Data?\nPure Data (Pd) is a powerful, open-source environment for creative coding, offering a uniquely visual approach to programming that is especially suited for artists, musicians, and interactive media designers. Its intuitive interface and modular structure make it a flexible and accessible tool for developing real-time audio and visual projects—from live performances to experimental installations.\nOne of Pure Data’s standout features is its graphical programming interface, which replaces traditional lines of code with visual objects and patch cords. This allows users to construct complex behaviors by connecting elements on screen, making it easier to prototype and refine creative ideas. Real-time processing capabilities mean that audio and visual data can be generated, modified, and responded to instantly—ideal for performances, generative art, or interactive systems that react to sensors or user input.\nBeyond its creative potential, Pure Data offers practical advantages: it is cross-platform, running on Windows, macOS, and Linux, and integrates easily with tools like Arduino, Raspberry Pi, and Max/MSP, enabling hybrid systems that combine digital and physical components. A rich ecosystem of external libraries supports advanced functions like synthesis, visualization, and computer vision. Its open-source nature encourages exploration and collaboration, with a supportive community, extensive documentation, and countless tutorials available. Because it’s free and widely used in education, Pd is not only an effective tool for artistic expression but also a valuable learning resource for developing a strong foundation in programming and multimedia design.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/introduction.html#what-is-creative-coding",
    "href": "chapters/introduction.html#what-is-creative-coding",
    "title": "1  Introduction",
    "section": "1.3 What is Creative Coding?",
    "text": "1.3 What is Creative Coding?\nCreative coding is the practice of using programming as a tool for artistic expression. It transforms code from a purely functional medium into a creative one, enabling the development of visual art, music, interactive experiences, and experimental media. This approach encourages artists, designers, and technologists to explore beyond the limits of traditional art forms, embracing code as a flexible and dynamic means of invention and communication.\nThe applications of creative coding are diverse, ranging from generative visuals and algorithmic design to responsive installations and live audiovisual performances. Creators often use languages and environments specifically designed to support creative work, such as Processing, OpenFrameworks, Max/MSP, and Pure Data. These platforms make it easier to manipulate data, control media in real time, and experiment with unconventional interfaces and outputs.\nImportantly, creative coding transcends the boundaries of specific disciplines. It can intersect with visual art, music, dance, theater, architecture, and even narrative writing. What unites these practices is the use of code as an expressive tool—one that invites innovation, play, and conceptual exploration. Closely tied to the values of the open-source movement, creative coding thrives in a culture of sharing, where artists and developers freely exchange code, tutorials, and ideas. This collaborative ecosystem fosters continuous learning and reinvention, empowering creators to expand what is possible through digital technology.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/introduction.html#getting-started",
    "href": "chapters/introduction.html#getting-started",
    "title": "1  Introduction",
    "section": "1.4 Getting Started",
    "text": "1.4 Getting Started\nThis section will guide you through the installation of Pure Data Vanilla, the official and minimal distribution of Pure Data, on Windows, macOS, and Linux systems. The installation process is straightforward and will have you up and running in no time.\n\n1.4.1 Installing Pure Data Vanilla\nThe following is a step-by-step installation of Pure Data Vanilla, the official and minimal distribution of Pure Data, on Windows, macOS, and Linux systems.\n\n\n1.4.2 What is Pure Data “Vanilla”?\nPure Data (Pd) Vanilla is the standard version maintained by its original creator, Miller Puckette. It is lightweight, highly stable, and the most recommended version for beginners and experienced users alike.\n\n\n\n1.4.3 Installing on Windows\n\n1.4.3.1 Download the Installer\n\nVisit the official Pure Data website: https://puredata.info/downloads/pure-data\nScroll down to the Windows section.\nClick the latest version link (e.g., pd-0.55-2.windows-installer.exe).\n\n\n\n1.4.3.2 Run the Installer\n\nLocate the downloaded .exe file in your Downloads folder.\nDouble-click to run the installer.\nFollow the installation wizard:\n\nChoose the installation location (default is fine).\nAllow the program to create a Start Menu shortcut.\n\n\n\n\n1.4.3.3 Verify Installation\n\nAfter installation, open Pure Data from the Start Menu or desktop shortcut.\nThe main Pd window should appear with a blank patch ready.\n\n\n\n\n\n1.4.4 Installing on macOS\n\n1.4.4.1 Download the Disk Image\n\nVisit: https://msp.ucsd.edu/software.html\nScroll to the macOS section.\nDownload the .dmg file (e.g., Pd-0.54-1.dmg).\n\n\n\n1.4.4.2 Install the Application\n\nOpen the downloaded .dmg file.\nDrag the Pure Data icon into the Applications folder.\n\n\n\n1.4.4.3 Open Pure Data\n\nOpen your Applications folder.\nRight-click (or Ctrl + click) the Pure Data icon and select Open.\n\nThe first time, macOS may warn that the app is from an unidentified developer.\nConfirm to proceed.\n\n\n\n\n1.4.4.4 Optional: Enable Audio Permissions\n\nIf prompted, allow Pure Data to access the microphone.\nOpen System Preferences &gt; Security & Privacy &gt; Microphone and ensure Pure Data is enabled.\n\n\n\n\n\n1.4.5 Installing on Linux\nPure Data is available in the package repositories of most major Linux distributions. Below are instructions for popular systems.\n\n1.4.5.1 Debian/Ubuntu-based Systems\nsudo apt update\nsudo apt install puredata\n\n\n1.4.5.2 Fedora\nsudo dnf install puredata\n\n\n1.4.5.3 Arch Linux\nsudo pacman -S puredata\n\n\n1.4.5.4 Verify Installation\n\nOpen a terminal and type pd.\nThe Pure Data GUI should launch, displaying a blank patch.\nIf you encounter issues, check your package manager or consult the Pure Data community for troubleshooting.\n\n\n\n\n1.4.6 Installing Externals\nPure Data’s functionality can be extended through the use of externals—additional libraries that provide new objects and features. These externals are created by the Pd community and can add everything from new audio effects to advanced data processing tools. Installing externals is straightforward thanks to Pure Data’s built-in package manager.\n\n1.4.6.1 Step 1: Open Pure Data\n\nLaunch Pure Data (Pd) on your computer.\nMake sure you are using the Vanilla version for best compatibility with the package manager.\n\n\n\n1.4.6.2 Step 2: Access the “Find Externals” Tool\n\nIn the Pure Data menu, go to Help → Find Externals…\nThis opens the Deken package manager, which allows you to search for and install externals directly from within Pd.\n\n\n\n1.4.6.3 Step 3: Search for an External\n\nIn the search bar, type the name of the external or library you want to install (for example, zexy, cyclone, or iemlib).\nPress Enter or click the Search button.\nA list of matching externals will appear, showing available versions for your platform.\n\n\n\n1.4.6.4 Step 4: Install the External\n\nClick on the desired external in the list.\nChoose the version that matches your operating system and Pd version.\nClick Install.\nThe external will be downloaded and placed in your Pd externals folder (typically ~/Documents/Pd/externals on macOS and Linux, or C:\\Users\\&lt;YourName&gt;\\Documents\\Pd\\externals on Windows).\n\n\n\n1.4.6.5 Step 5: Add the External to Your Pd Path (if needed)\n\nMost externals are automatically available after installation.\nIf Pd cannot find the external, you may need to add its folder to Pd’s search path:\n\nGo to Preferences → Path…\nClick New and add the path to the external’s folder (for example, ~/Documents/Pd/externals/cyclone).\nClick OK and restart Pd.\n\n\n\n\n1.4.6.6 Step 6: Use the External in Your Patch\n\nIn your patch, create an object with the name of the external’s library, followed by the object you want to use.\nFor example, to use the counter object from the cyclone library:\n[cyclone/counter]\nSome libraries require you to load them with a special object, such as [declare -lib cyclone] at the top of your patch.\n\n\n\n1.4.6.7 Step 7: Verify Installation\n\nIf the object appears without errors (no red box), the external is installed correctly.\nIf you see errors, double-check the installation path and that you are using the correct object/library name.\n\n\n\n1.4.6.8 Manual Installation (Advanced)\nIf you need to install an external manually:\n\nDownload the external from https://deken.puredata.info/ or the developer’s website.\nExtract the files to your Pd externals folder.\nAdd the folder to Pd’s path as described above.\n\n\nTip: Always check the documentation for each external, as installation steps or requirements may vary.\n\nFor more details, see the official Pure Data documentation on externals.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "chapters/music-scale-generator.html",
    "href": "chapters/music-scale-generator.html",
    "title": "5  Random Melody Generator",
    "section": "",
    "text": "5.1 Patch Overview\nThis chapter provides a step-by-step explanation of the music_scale_B.pd Pure Data patch. The patch demonstrates how to generate a melody using a musical scale, store it in an array, and play it back using MIDI.\nThe patch is organized into several functional blocks:\nBelow is a simplified diagram of the main data flow:\nflowchart TD\n    A[Scale Input] --&gt; B[Melody Generation]\n    B --&gt; C[Store in Array]\n    C --&gt; D[Playback Control]\n    D --&gt; E[MIDI Output]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/music-scale-generator.html#patch-overview",
    "href": "chapters/music-scale-generator.html#patch-overview",
    "title": "5  Random Melody Generator",
    "section": "",
    "text": "Scale and Melody Generation\nMelody Storage\nPlayback Control\nMIDI Output",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/music-scale-generator.html#scale-and-melody-generation",
    "href": "chapters/music-scale-generator.html#scale-and-melody-generation",
    "title": "5  Random Melody Generator",
    "section": "5.2 Scale and Melody Generation",
    "text": "5.2 Scale and Melody Generation\n\n5.2.1 Scale Definition\nThe patch starts with a message box containing the scale intervals:\n0 2 4 5 7 9 11\nFor example, this represents a major scale in semitones accordding to the following mapping:\n\n\n\n\nNote\nInterval\n\n\n\n\nC\n0\n\n\nC# / Db\n1\n\n\nD\n2\n\n\nD# / Eb\n3\n\n\nE\n4\n\n\nF\n5\n\n\nF# / Gb\n6\n\n\nG\n7\n\n\nG# / Ab\n8\n\n\nA\n9\n\n\nA# / Bb\n10\n\n\nB\n11\n\n\n\n\n \nThe scale is appended to a list and processed to determine its length.\n\n\n5.2.2 Random Note Selection\nA random number between 0 and 47 is generated (random 48), then shifted up by 60 to get a MIDI note in a typical range.\nThe note is then mapped to the scale using modulo operations and list indexing.\n\n\n5.2.3 Melody Construction\nThe patch uses a loop (until, i, + 1) to generate a sequence of notes.\nEach note is calculated based on the scale and stored in a list.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/music-scale-generator.html#melody-storage",
    "href": "chapters/music-scale-generator.html#melody-storage",
    "title": "5  Random Melody Generator",
    "section": "5.3 Melody Storage",
    "text": "5.3 Melody Storage\nThe generated melody is stored in a Pure Data array called melody.\nThe array is visualized in the patch for reference.\n\n\n\n\n\ngraph LR\n    MelodyList --&gt;|tabwrite| MelodyArray",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/music-scale-generator.html#playback-control",
    "href": "chapters/music-scale-generator.html#playback-control",
    "title": "5  Random Melody Generator",
    "section": "5.4 Playback Control",
    "text": "5.4 Playback Control\nA metro object (metronome) triggers playback at a tempo set by a horizontal slider.\nEach bang from the metronome advances an index, which reads the next note from the melody array.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/music-scale-generator.html#midi-output",
    "href": "chapters/music-scale-generator.html#midi-output",
    "title": "5  Random Melody Generator",
    "section": "5.5 MIDI Output",
    "text": "5.5 MIDI Output\nThe note value is sent to a makenote object, which creates a MIDI note with velocity and duration.\nThe note is then sent to the noteout object, which outputs the MIDI note to your system’s MIDI device.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/music-scale-generator.html#step-by-step-data-flow",
    "href": "chapters/music-scale-generator.html#step-by-step-data-flow",
    "title": "5  Random Melody Generator",
    "section": "5.6 Step-by-Step Data Flow",
    "text": "5.6 Step-by-Step Data Flow\n\nInitialize Scale: The scale intervals are defined and appended to a list.\nGenerate Melody: A loop generates random notes mapped to the scale, storing them in the melody array.\nPlayback: A metronome triggers reading from the array, sending notes to MIDI output.\nVisualization: The melody array is displayed as a graph in the patch.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/music-scale-generator.html#key-objects-and-their-roles",
    "href": "chapters/music-scale-generator.html#key-objects-and-their-roles",
    "title": "5  Random Melody Generator",
    "section": "5.7 Key Objects and Their Roles",
    "text": "5.7 Key Objects and Their Roles\n\n\n\n\nObject\nPurpose\n\n\n\n\nrandom 48\nGenerates random note indices\n\n\n+ 60\nShifts notes to a higher MIDI octave\n\n\nmod 12\nMaps notes to scale degrees\n\n\nlist-idx\nRetrieves scale degree from the list\n\n\ntabwrite\nWrites notes to the melody array\n\n\nmetro\nControls playback timing\n\n\ntabread\nReads notes from the melody array\n\n\nmakenote\nCreates MIDI notes with velocity/duration\n\n\nnoteout\nSends MIDI notes to output",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/music-scale-generator.html#diagram-melody-generation-and-playback",
    "href": "chapters/music-scale-generator.html#diagram-melody-generation-and-playback",
    "title": "5  Random Melody Generator",
    "section": "5.8 Diagram: Melody Generation and Playback",
    "text": "5.8 Diagram: Melody Generation and Playback\n\n\n\n\n\nflowchart TD\n    S[Scale Message] --&gt; L[list Append]\n    L --&gt; R[random + Offset]\n    R --&gt; M[Modulo/Indexing]\n    M --&gt; A[Melody Array]\n    A --&gt; P[Playback - metro, tabread]\n    P --&gt; MN[makenote]\n    MN --&gt; NO[noteout]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/music-scale-generator.html#summary",
    "href": "chapters/music-scale-generator.html#summary",
    "title": "5  Random Melody Generator",
    "section": "5.9 Summary",
    "text": "5.9 Summary\nThis patch demonstrates how to algorithmically generate a melody using a musical scale, store it, and play it back via MIDI in Pure Data. The modular structure allows for easy experimentation with different scales, lengths, and playback parameters.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/chapter.html",
    "href": "chapters/chapter.html",
    "title": "4  Chapter 2: Specific Subjects or Themes",
    "section": "",
    "text": "4.1 Topic 1: Overview\nIn this chapter, we will explore various specific subjects or themes that are relevant to our book.\nProvide an overview of the first topic, discussing its significance and relevance.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Specific Subjects or Themes</span>"
    ]
  },
  {
    "objectID": "chapters/chapter.html#topic-2-in-depth-analysis",
    "href": "chapters/chapter.html#topic-2-in-depth-analysis",
    "title": "4  Chapter 2: Specific Subjects or Themes",
    "section": "4.2 Topic 2: In-Depth Analysis",
    "text": "4.2 Topic 2: In-Depth Analysis\nDelve deeper into the second topic, presenting detailed information and insights.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Specific Subjects or Themes</span>"
    ]
  },
  {
    "objectID": "chapters/chapter.html#topic-3-case-studies",
    "href": "chapters/chapter.html#topic-3-case-studies",
    "title": "4  Chapter 2: Specific Subjects or Themes",
    "section": "4.3 Topic 3: Case Studies",
    "text": "4.3 Topic 3: Case Studies\nInclude case studies or examples that illustrate the concepts discussed in this chapter.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Specific Subjects or Themes</span>"
    ]
  },
  {
    "objectID": "chapters/chapter.html#conclusion",
    "href": "chapters/chapter.html#conclusion",
    "title": "4  Chapter 2: Specific Subjects or Themes",
    "section": "4.4 Conclusion",
    "text": "4.4 Conclusion\nSummarize the key points covered in this chapter and their implications for the overall theme of the book.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Specific Subjects or Themes</span>"
    ]
  },
  {
    "objectID": "chapters/conclusion.html",
    "href": "chapters/conclusion.html",
    "title": "5  Conclusion",
    "section": "",
    "text": "5.1 Key Takeaways\nIn this chapter, we summarize the key points discussed throughout the book. We reflect on the main topics introduced in the first chapter and the detailed discussions in the second chapter.\nThank you for reading! We hope this book has provided valuable insights and knowledge.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conclusion</span>"
    ]
  },
  {
    "objectID": "chapters/conclusion.html#key-takeaways",
    "href": "chapters/conclusion.html#key-takeaways",
    "title": "5  Conclusion",
    "section": "",
    "text": "Highlight the main objectives of the book.\nDiscuss the significance of the topics covered.\nEncourage further exploration and learning in the subject area.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Conclusion</span>"
    ]
  },
  {
    "objectID": "chapters/tools/music-scale-generator.html",
    "href": "chapters/tools/music-scale-generator.html",
    "title": "4  Random Melody Generator",
    "section": "",
    "text": "4.1 Patch Overview\nThis chapter provides a step-by-step explanation of the music_scale_B.pd Pure Data patch. The patch demonstrates how to generate a melody using a musical scale, store it in an array, and play it back using MIDI.\nThe patch is organized into several functional blocks:\nBelow is a simplified diagram of the main data flow:\nflowchart TD\n    A[Scale Input] --&gt; B[Melody Generation]\n    B --&gt; C[Store in Array]\n    C --&gt; D[Playback Control]\n    D --&gt; E[MIDI Output]",
    "crumbs": [
      "Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/tools/music-scale-generator.html#patch-overview",
    "href": "chapters/tools/music-scale-generator.html#patch-overview",
    "title": "4  Random Melody Generator",
    "section": "",
    "text": "Scale and Melody Generation\nMelody Storage\nPlayback Control\nMIDI Output",
    "crumbs": [
      "Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/tools/music-scale-generator.html#scale-and-melody-generation",
    "href": "chapters/tools/music-scale-generator.html#scale-and-melody-generation",
    "title": "4  Random Melody Generator",
    "section": "4.2 Scale and Melody Generation",
    "text": "4.2 Scale and Melody Generation\n\n4.2.1 Scale Definition\nThe patch starts with a message box containing the scale intervals:\n0 2 4 5 7 9 11\nFor example, this represents a major scale in semitones accordding to the following mapping:\n\n\n\n\nNote\nInterval\n\n\n\n\nC\n0\n\n\nC# / Db\n1\n\n\nD\n2\n\n\nD# / Eb\n3\n\n\nE\n4\n\n\nF\n5\n\n\nF# / Gb\n6\n\n\nG\n7\n\n\nG# / Ab\n8\n\n\nA\n9\n\n\nA# / Bb\n10\n\n\nB\n11\n\n\n\n\n \nThe scale is appended to a list and processed to determine its length.\n\n\n4.2.2 Random Note Selection\nA random number between 0 and 47 is generated (random 48), then shifted up by 60 to get a MIDI note in a typical range.\nThe note is then mapped to the scale using modulo operations and list indexing.\n\n\n4.2.3 Melody Construction\nThe patch uses a loop (until, i, + 1) to generate a sequence of notes.\nEach note is calculated based on the scale and stored in a list.",
    "crumbs": [
      "Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/tools/music-scale-generator.html#melody-storage",
    "href": "chapters/tools/music-scale-generator.html#melody-storage",
    "title": "4  Random Melody Generator",
    "section": "4.3 Melody Storage",
    "text": "4.3 Melody Storage\nThe generated melody is stored in a Pure Data array called melody.\nThe array is visualized in the patch for reference.\n\n\n\n\n\ngraph LR\n    MelodyList --&gt;|tabwrite| MelodyArray",
    "crumbs": [
      "Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/tools/music-scale-generator.html#playback-control",
    "href": "chapters/tools/music-scale-generator.html#playback-control",
    "title": "4  Random Melody Generator",
    "section": "4.4 Playback Control",
    "text": "4.4 Playback Control\nA metro object (metronome) triggers playback at a tempo set by a horizontal slider.\nEach bang from the metronome advances an index, which reads the next note from the melody array.",
    "crumbs": [
      "Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/tools/music-scale-generator.html#midi-output",
    "href": "chapters/tools/music-scale-generator.html#midi-output",
    "title": "4  Random Melody Generator",
    "section": "4.5 MIDI Output",
    "text": "4.5 MIDI Output\nThe note value is sent to a makenote object, which creates a MIDI note with velocity and duration.\nThe note is then sent to the noteout object, which outputs the MIDI note to your system’s MIDI device.",
    "crumbs": [
      "Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/tools/music-scale-generator.html#step-by-step-data-flow",
    "href": "chapters/tools/music-scale-generator.html#step-by-step-data-flow",
    "title": "4  Random Melody Generator",
    "section": "4.6 Step-by-Step Data Flow",
    "text": "4.6 Step-by-Step Data Flow\n\nInitialize Scale: The scale intervals are defined and appended to a list.\nGenerate Melody: A loop generates random notes mapped to the scale, storing them in the melody array.\nPlayback: A metronome triggers reading from the array, sending notes to MIDI output.\nVisualization: The melody array is displayed as a graph in the patch.",
    "crumbs": [
      "Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/tools/music-scale-generator.html#key-objects-and-their-roles",
    "href": "chapters/tools/music-scale-generator.html#key-objects-and-their-roles",
    "title": "4  Random Melody Generator",
    "section": "4.7 Key Objects and Their Roles",
    "text": "4.7 Key Objects and Their Roles\n\n\n\n\nObject\nPurpose\n\n\n\n\nrandom 48\nGenerates random note indices\n\n\n+ 60\nShifts notes to a higher MIDI octave\n\n\nmod 12\nMaps notes to scale degrees\n\n\nlist-idx\nRetrieves scale degree from the list\n\n\ntabwrite\nWrites notes to the melody array\n\n\nmetro\nControls playback timing\n\n\ntabread\nReads notes from the melody array\n\n\nmakenote\nCreates MIDI notes with velocity/duration\n\n\nnoteout\nSends MIDI notes to output",
    "crumbs": [
      "Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/tools/music-scale-generator.html#diagram-melody-generation-and-playback",
    "href": "chapters/tools/music-scale-generator.html#diagram-melody-generation-and-playback",
    "title": "4  Random Melody Generator",
    "section": "4.8 Diagram: Melody Generation and Playback",
    "text": "4.8 Diagram: Melody Generation and Playback\n\n\n\n\n\nflowchart TD\n    S[Scale Message] --&gt; L[list Append]\n    L --&gt; R[random + Offset]\n    R --&gt; M[Modulo/Indexing]\n    M --&gt; A[Melody Array]\n    A --&gt; P[Playback - metro, tabread]\n    P --&gt; MN[makenote]\n    MN --&gt; NO[noteout]",
    "crumbs": [
      "Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/tools/music-scale-generator.html#summary",
    "href": "chapters/tools/music-scale-generator.html#summary",
    "title": "4  Random Melody Generator",
    "section": "4.9 Summary",
    "text": "4.9 Summary\nThis patch demonstrates how to algorithmically generate a melody using a musical scale, store it, and play it back via MIDI in Pure Data. The modular structure allows for easy experimentation with different scales, lengths, and playback parameters.",
    "crumbs": [
      "Tools",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Random Melody Generator</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html",
    "href": "chapters/sequencers.html",
    "title": "3  Sequencers",
    "section": "",
    "text": "3.1 Random Melody Generator\nThis chapter provides a step-by-step explanation of the music-scale-B.pd Pure Data patch. The patch demonstrates how to generate a melody using a musical scale, store it in an array, and play it back using MIDI.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#patch-overview",
    "href": "chapters/sequencers.html#patch-overview",
    "title": "4  Sequencers",
    "section": "4.2 Patch Overview",
    "text": "4.2 Patch Overview\nThe patch is organized into several functional blocks:\n\nScale and Melody Generation\nMelody Storage\nPlayback Control\nMIDI Output\n\nBelow is a simplified diagram of the main data flow:\n\n\n\n\n\nflowchart TD\n    A[Scale Input] --&gt; B[Melody Generation]\n    B --&gt; C[Store in Array]\n    C --&gt; D[Playback Control]\n    D --&gt; E[MIDI Output]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#scale-and-melody-generation",
    "href": "chapters/sequencers.html#scale-and-melody-generation",
    "title": "4  Sequencers",
    "section": "4.2 Scale and Melody Generation",
    "text": "4.2 Scale and Melody Generation\n\n4.2.1 Scale Definition\nThe patch starts with a message box containing the scale intervals:\n0 2 4 5 7 9 11\nFor example, this represents a major scale in semitones accordding to the following mapping:\n\n\n\n\nNote\nInterval\n\n\n\n\nC\n0\n\n\nC# / Db\n1\n\n\nD\n2\n\n\nD# / Eb\n3\n\n\nE\n4\n\n\nF\n5\n\n\nF# / Gb\n6\n\n\nG\n7\n\n\nG# / Ab\n8\n\n\nA\n9\n\n\nA# / Bb\n10\n\n\nB\n11\n\n\n\n\n \nThe scale is appended to a list and processed to determine its length.\n\n\n4.2.2 Random Note Selection\nA random number between 0 and 47 is generated (random 48), then shifted up by 60 to get a MIDI note in a typical range.\nThe note is then mapped to the scale using modulo operations and list indexing.\n\n\n4.2.3 Melody Construction\nThe patch uses a loop (until, i, + 1) to generate a sequence of notes.\nEach note is calculated based on the scale and stored in a list.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#melody-storage",
    "href": "chapters/sequencers.html#melody-storage",
    "title": "4  Sequencers",
    "section": "4.2 Melody Storage",
    "text": "4.2 Melody Storage\nThe generated melody is stored in a Pure Data array called melody.\nThe array is visualized in the patch for reference.\n\n\n\n\n\ngraph LR\n    MelodyList --&gt;|tabwrite| MelodyArray",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#playback-control",
    "href": "chapters/sequencers.html#playback-control",
    "title": "4  Sequencers",
    "section": "4.2 Playback Control",
    "text": "4.2 Playback Control\nA metro object (metronome) triggers playback at a tempo set by a horizontal slider.\nEach bang from the metronome advances an index, which reads the next note from the melody array.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#midi-output",
    "href": "chapters/sequencers.html#midi-output",
    "title": "4  Sequencers",
    "section": "4.2 MIDI Output",
    "text": "4.2 MIDI Output\nThe note value is sent to a makenote object, which creates a MIDI note with velocity and duration.\nThe note is then sent to the noteout object, which outputs the MIDI note to your system’s MIDI device.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#step-by-step-data-flow",
    "href": "chapters/sequencers.html#step-by-step-data-flow",
    "title": "4  Sequencers",
    "section": "4.2 Step-by-Step Data Flow",
    "text": "4.2 Step-by-Step Data Flow\n\nInitialize Scale: The scale intervals are defined and appended to a list.\nGenerate Melody: A loop generates random notes mapped to the scale, storing them in the melody array.\nPlayback: A metronome triggers reading from the array, sending notes to MIDI output.\nVisualization: The melody array is displayed as a graph in the patch.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#key-objects-and-their-roles",
    "href": "chapters/sequencers.html#key-objects-and-their-roles",
    "title": "4  Sequencers",
    "section": "4.2 Key Objects and Their Roles",
    "text": "4.2 Key Objects and Their Roles\n\n\n\n\nObject\nPurpose\n\n\n\n\nrandom 48\nGenerates random note indices\n\n\n+ 60\nShifts notes to a higher MIDI octave\n\n\nmod 12\nMaps notes to scale degrees\n\n\nlist-idx\nRetrieves scale degree from the list\n\n\ntabwrite\nWrites notes to the melody array\n\n\nmetro\nControls playback timing\n\n\ntabread\nReads notes from the melody array\n\n\nmakenote\nCreates MIDI notes with velocity/duration\n\n\nnoteout\nSends MIDI notes to output",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#diagram-melody-generation-and-playback",
    "href": "chapters/sequencers.html#diagram-melody-generation-and-playback",
    "title": "4  Sequencers",
    "section": "4.2 Diagram: Melody Generation and Playback",
    "text": "4.2 Diagram: Melody Generation and Playback\n\n\n\n\n\nflowchart TD\n    S[Scale Message] --&gt; L[list Append]\n    L --&gt; R[random + Offset]\n    R --&gt; M[Modulo/Indexing]\n    M --&gt; A[Melody Array]\n    A --&gt; P[Playback - metro, tabread]\n    P --&gt; MN[makenote]\n    MN --&gt; NO[noteout]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#summary",
    "href": "chapters/sequencers.html#summary",
    "title": "4  Sequencers",
    "section": "4.2 Summary",
    "text": "4.2 Summary\nThis patch demonstrates how to algorithmically generate a melody using a musical scale, store it, and play it back via MIDI in Pure Data. The modular structure allows for easy experimentation with different scales, lengths, and playback parameters.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#random-melody-generator",
    "href": "chapters/sequencers.html#random-melody-generator",
    "title": "3  Sequencers",
    "section": "",
    "text": "Random Melody Generator\n\n\n\n\n3.1.1 Patch Overview\nThe patch is organized into several functional blocks:\n\nScale and Melody Generation\nMelody Storage\nPlayback Control\nMIDI Output\n\nBelow is a simplified diagram of the main data flow:\n\n\n\n\n\nflowchart TD\n    A[Scale Input] --&gt; B[Melody Generation]\n    B --&gt; C[Store in Array]\n    C --&gt; D[Playback Control]\n    D --&gt; E[MIDI Output]\n\n\n\n\n\n\n\n\n\n3.1.2 Scale and Melody Generation\n\n3.1.2.1 Scale Definition\nThe patch starts with a message box containing the scale intervals:\n0 2 4 5 7 9 11\nFor example, this represents a major scale in semitones accordding to the following mapping:\n\n\n\n\nNote\nInterval\n\n\n\n\nC\n0\n\n\nC# / Db\n1\n\n\nD\n2\n\n\nD# / Eb\n3\n\n\nE\n4\n\n\nF\n5\n\n\nF# / Gb\n6\n\n\nG\n7\n\n\nG# / Ab\n8\n\n\nA\n9\n\n\nA# / Bb\n10\n\n\nB\n11\n\n\n\n\n \nThe scale is appended to a list and processed to determine its length.\n\n\n3.1.2.2 Random Note Selection\nA random number between 0 and 47 is generated (random 48), then shifted up by 60 to get a MIDI note in a typical range.\nThe note is then mapped to the scale using modulo operations and list indexing.\n\n\n3.1.2.3 Melody Construction\nThe patch uses a loop (until, i, + 1) to generate a sequence of notes.\nEach note is calculated based on the scale and stored in a list.\n\n\n\n\n3.1.3 Melody Storage\nThe generated melody is stored in a Pure Data array called melody.\nThe array is visualized in the patch for reference.\n\n\n\n\n\ngraph LR\n    MelodyList --&gt;|tabwrite| MelodyArray\n\n\n\n\n\n\n\n\n\n3.1.4 Playback Control\nA metro object (metronome) triggers playback at a tempo set by a horizontal slider.\nEach bang from the metronome advances an index, which reads the next note from the melody array.\n\n\n\n3.1.5 MIDI Output\nThe note value is sent to a makenote object, which creates a MIDI note with velocity and duration.\nThe note is then sent to the noteout object, which outputs the MIDI note to your system’s MIDI device.\n\n\n\n3.1.6 Step-by-Step Data Flow\n\nInitialize Scale: The scale intervals are defined and appended to a list.\nGenerate Melody: A loop generates random notes mapped to the scale, storing them in the melody array.\nPlayback: A metronome triggers reading from the array, sending notes to MIDI output.\nVisualization: The melody array is displayed as a graph in the patch.\n\n\n\n\n3.1.7 Key Objects and Their Roles\n\n\n\n\nObject\nPurpose\n\n\n\n\nrandom 48\nGenerates random note indices\n\n\n+ 60\nShifts notes to a higher MIDI octave\n\n\nmod 12\nMaps notes to scale degrees\n\n\nlist-idx\nRetrieves scale degree from the list\n\n\ntabwrite\nWrites notes to the melody array\n\n\nmetro\nControls playback timing\n\n\ntabread\nReads notes from the melody array\n\n\nmakenote\nCreates MIDI notes with velocity/duration\n\n\nnoteout\nSends MIDI notes to output\n\n\n\n\n\n\n\n3.1.8 Diagram: Melody Generation and Playback\n\n\n\n\n\nflowchart TD\n    S[Scale Message] --&gt; L[list Append]\n    L --&gt; R[random + Offset]\n    R --&gt; M[Modulo/Indexing]\n    M --&gt; A[Melody Array]\n    A --&gt; P[Playback - metro, tabread]\n    P --&gt; MN[makenote]\n    MN --&gt; NO[noteout]\n\n\n\n\n\n\n\n\n\n3.1.9 Summary\nThis patch demonstrates how to algorithmically generate a melody using a musical scale, store it, and play it back via MIDI in Pure Data. The modular structure allows for easy experimentation with different scales, lengths, and playback parameters.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#section",
    "href": "chapters/sequencers.html#section",
    "title": "4  Sequencers",
    "section": "4.3 ",
    "text": "4.3",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "chapters/sequencers.html#euclidean-sequencer",
    "href": "chapters/sequencers.html#euclidean-sequencer",
    "title": "3  Sequencers",
    "section": "3.2 Euclidean Sequencer",
    "text": "3.2 Euclidean Sequencer\nThis chapter provides a step-by-step explanation of the euclidean_sequencer.pd Pure Data patch. The patch demonstrates how to create a Euclidean sequencer that generates rhythmic patterns based on the Euclidean algorithm.\n\n3.2.1 Patch Overview\nThe patch is organized into several functional blocks: - Euclidean Algorithm - Rhythm Generation - Playback Control - MIDI Output Below is a simplified diagram of the main data flow",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Sequencers</span>"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Creative Coding with Pure Data",
    "section": "",
    "text": "puredata.info/downloads/pure-data↩︎",
    "crumbs": [
      "Preface"
    ]
  }
]